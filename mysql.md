```
MySQL 隔離級別有以下幾種：

讀未提交（Read Uncommitted）
  最低的隔離級別，允許讀取其他事務尚未提交的變更，可能導致髒讀（Dirty Read）。
  效能：
    效能最高，因為不需要加鎖。
    不會阻止其他事務讀取或修改相同的數據。
  是否鎖資料：
    不會鎖資料，但可能導致脏讀。
  適用場景：
    不需要數據一致性保證，且追求極高的效能，如簡單的數據分析場景。

讀已提交（Read Committed）
  保證只能讀取其他事務已提交的數據，避免髒讀，但可能出現不可重複讀（Non-repeatable Read）。
  效能：
    相對較高，避免了脏讀，但開銷低於更高隔離級別。
    只需在讀取數據時獲取共享鎖（讀鎖），在修改時加排他鎖（寫鎖）。
  是否鎖資料：
    部分鎖資料：
    讀操作：不會長時間鎖定資料，但會在讀時短暫加共享鎖。
    寫操作：修改時會加排他鎖。
  適用場景：
    大部分日常應用的理想選擇，如 OLTP 系統。

可重複讀（Repeatable Read）
  保證同一事務內多次讀取相同數據的結果一致，避免髒讀與不可重複讀，但可能出現幻讀（Phantom Read）。
  MySQL InnoDB 的默認隔離級別。
  效能：
    效能略低於 READ COMMITTED，因為需要維持一致性快照來避免不可重複讀。
    MySQL 使用 間隙鎖（gap locks）來防止幻讀，可能導致更多鎖競爭。
  是否鎖資料：
    會鎖資料：
    讀操作：會在查詢範圍內加共享鎖，並可能加間隙鎖。
    寫操作：會加排他鎖並防止其他事務插入新記錄。
  適用場景：
    MySQL InnoDB 的默認隔離級別，適合需要數據一致性但又需要一定性能的場景。

可序列化（Serializable）
  最高的隔離級別，通過強制事務順序執行，完全避免髒讀、不可重複讀與幻讀，但可能大幅降低並發性能。
  效能：
    效能最差，因為所有操作都會被序列化，導致並發性能大幅下降。
    每次查詢都需要加鎖，極大地增加了系統開銷。
  是否鎖資料：
    會鎖資料：
    讀取範圍內的所有數據都會被鎖定，防止其他事務插入或修改。
  適用場景：
    極端情況下需要強一致性的場景，如財務系統。

```
```
效能與鎖定的綜合比較
| 隔離級別            | 效能 | 是否鎖資料           |  特點 |
| READ UNCOMMITTED   | 最高 | 不鎖資料	            |  無一致性保證，適合快速讀取需求。
| READ COMMITTED     | 高   | 部分鎖資料	          |  避免脏讀，適合大多數應用場景。
| REPEATABLE READ    | 中   | 會鎖資料（含間隙鎖）  |  避免脏讀與不可重複讀，是 MySQL 默認選擇。
| SERIALIZABLE       | 低   | 會鎖資料（讀寫都鎖）  |  強一致性，但效能低，僅適用於特殊場景。

如果需要最高效能且對一致性要求不高，選擇 READ UNCOMMITTED 或 READ COMMITTED。
如果需要一致性（避免不可重複讀或幻讀），選擇 REPEATABLE READ。
只有在需要強一致性保證的情況下（如金融交易），才考慮 SERIALIZABLE。
```
